const { spawn } = require('child_process');
const path = require('path');

const bridgePath = path.resolve(__dirname, '..', 'dist', 'index.js');
const child = spawn('node', [bridgePath], { stdio: ['pipe','pipe','pipe'] });

child.stderr.on('data', d => process.stderr.write(d.toString()));

let buffer = '';
child.stdout.on('data', (chunk) => {
  buffer += chunk.toString();
  let idx;
  while ((idx = buffer.indexOf('\n')) >= 0) {
    const line = buffer.slice(0, idx).trim();
    buffer = buffer.slice(idx + 1);
    if (!line) continue;
    try {
      const obj = JSON.parse(line);
      console.log('<<', JSON.stringify(obj, null, 2));
    } catch (e) {
      console.log('<< raw ->', line);
    }
  }
});

let id = 1;
function send(method, params) {
  const req = { id: id++, method, params };
  child.stdin.write(JSON.stringify(req) + '\n');
  return req.id;
}

async function run() {
  // create session
  const sessionReqId = send('query.createSession', {});
  // small delay to capture response
  await new Promise(r => setTimeout(r, 150));

  // For simplicity, listen for a response containing the created sessionId in stdout
  // In production you'd correlate by id. Here we just send a run with a known SQL.
  // Adjust connection config to match your local Postgres
  const connection = { host: '127.0.0.1', port: 5432, user: 'postgres', password: 'postgres', database: 'postgres' };
  // Simple query (generate many rows for streaming test)
  const sql = 'SELECT generate_series(1,1000) as n';
  const createRespId = send('query.createSession', {});
  // Wait a bit then pick the last created sessionId by capturing the previous response...
  // For this test script, we will just request a session, then run immediately using a new random session id generated by bridge is asynchronously returned.
  // To be robust, parse responses and correlate by id. Simpler: issue query.run with a fake sessionId to see error handling.
  // Better approach: read stdout and find the response for createSession, then use that sessionId.
}

run();
